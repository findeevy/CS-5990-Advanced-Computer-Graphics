/**
 * @file render.cpp
 * @brief VulkanRenderer class implementation for Accelerender.
 *
 * This file contains the implementation of the VulkanRenderer class methods.
 *
 * @authors Finley Deevy, Eric Newton
 * @date 2025-11-10 (Updated)
 */

#define STB_IMAGE_IMPLEMENTATION
#include <stb/stb_image.h>

#define TINYOBJLOADER_IMPLEMENTATION
#if __has_include(<tiny_obj_loader.h>)
#include <tiny_obj_loader.h>
#else
#include "../external/tinyobjloader/tiny_obj_loader.h"
#endif

#include "render.hpp"

// Method implementations

void VulkanRenderer::run() {
  initWindow();
  initVulkan();
  mainLoop();
  cleanup();
}

uint32_t VulkanRenderer::findMemoryType(uint32_t typeFilter,
                                        vk::MemoryPropertyFlags properties) {
  vk::PhysicalDeviceMemoryProperties memProperties =
      physicalGPU.getMemoryProperties();

  for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
    if ((typeFilter & (1 << i)) &&
        (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
      return i;
    }
  }

  throw std::runtime_error("Failed to find suitable memory type!");
}

vk::SampleCountFlagBits VulkanRenderer::getMaxUsableSampleCount() {
  vk::PhysicalDeviceProperties physicalDeviceProperties =
      physicalGPU.getProperties();

  vk::SampleCountFlags counts =
      physicalDeviceProperties.limits.framebufferColorSampleCounts &
      physicalDeviceProperties.limits.framebufferDepthSampleCounts;

  if (counts & vk::SampleCountFlagBits::e64)
    return vk::SampleCountFlagBits::e64;
  if (counts & vk::SampleCountFlagBits::e32)
    return vk::SampleCountFlagBits::e32;
  if (counts & vk::SampleCountFlagBits::e16)
    return vk::SampleCountFlagBits::e16;
  if (counts & vk::SampleCountFlagBits::e8)
    return vk::SampleCountFlagBits::e8;
  if (counts & vk::SampleCountFlagBits::e4)
    return vk::SampleCountFlagBits::e4;
  if (counts & vk::SampleCountFlagBits::e2)
    return vk::SampleCountFlagBits::e2;

  return vk::SampleCountFlagBits::e1;
}

void VulkanRenderer::loadModel() {
  tinyobj::attrib_t attrib;
  std::vector<tinyobj::shape_t> shapes;
  std::vector<tinyobj::material_t> materials;
  std::string warn, err;

  if (!LoadObj(&attrib, &shapes, &materials, &warn, &err, MODEL_PATH.c_str())) {
    throw std::runtime_error(warn + err);
  }

  std::unordered_map<Vertex, uint32_t> uniqueVertices{};

  for (const auto &shape : shapes) {
    for (const auto &index : shape.mesh.indices) {
      Vertex vertex{};

      vertex.position = {attrib.vertices[3 * index.vertex_index + 0],
                         attrib.vertices[3 * index.vertex_index + 1],
                         attrib.vertices[3 * index.vertex_index + 2]};

      vertex.texCoord = {attrib.texcoords[2 * index.texcoord_index + 0],
                         1.0f - attrib.texcoords[2 * index.texcoord_index + 1]};

      vertex.color = {1.0f, 1.0f, 1.0f};

      if (!uniqueVertices.contains(vertex)) {
        uniqueVertices[vertex] = static_cast<uint32_t>(vertices.size());
        vertices.push_back(vertex);
      }

      indices.push_back(uniqueVertices[vertex]);
    }
  }
}

void VulkanRenderer::createDepthResources() {
  vk::Format depthFormat = findDepthFormat();

  createImage(swapChainExtent.width, swapChainExtent.height, 1, msaaSamples,
              depthFormat, vk::ImageTiling::eOptimal,
              vk::ImageUsageFlagBits::eDepthStencilAttachment,
              vk::MemoryPropertyFlagBits::eDeviceLocal, depthImage,
              depthImageMemory);

  depthImageView = vkutils::createImageView(device, depthImage, depthFormat, 
                                           vk::ImageAspectFlagBits::eDepth, 1);
}

vk::Format VulkanRenderer::findSupportedFormat(const std::vector<vk::Format> &candidates,
                                               vk::ImageTiling tiling,
                                               vk::FormatFeatureFlags features) {
  auto formatIt = std::ranges::find_if(candidates, [&](auto const format) {
    vk::FormatProperties props = physicalGPU.getFormatProperties(format);

    return (((tiling == vk::ImageTiling::eLinear) &&
             ((props.linearTilingFeatures & features) == features)) ||
            ((tiling == vk::ImageTiling::eOptimal) &&
             ((props.optimalTilingFeatures & features) == features)));
  });

  if (formatIt == candidates.end()) {
    throw std::runtime_error("Failed to find supported format!");
  }

  return *formatIt;
}

vk::Format VulkanRenderer::findDepthFormat() {
  return findSupportedFormat(
      {vk::Format::eD32Sfloat, vk::Format::eD32SfloatS8Uint,
       vk::Format::eD24UnormS8Uint},
      vk::ImageTiling::eOptimal,
      vk::FormatFeatureFlagBits::eDepthStencilAttachment);
}

bool VulkanRenderer::hasStencilComponent(vk::Format format) {
  return format == vk::Format::eD32SfloatS8Uint ||
         format == vk::Format::eD24UnormS8Uint;
}

void VulkanRenderer::createTextureImageView() {
  textureImageView = vkutils::createImageView(
      device, textureImage, vk::Format::eR8G8B8A8Srgb,
      vk::ImageAspectFlagBits::eColor, mipLevels);
}

void VulkanRenderer::createTextureSampler() {
  vk::PhysicalDeviceProperties properties = physicalGPU.getProperties();

  vk::SamplerCreateInfo samplerInfo;
  samplerInfo.magFilter = vk::Filter::eLinear;
  samplerInfo.minFilter = vk::Filter::eLinear;
  samplerInfo.mipmapMode = vk::SamplerMipmapMode::eLinear;
  samplerInfo.addressModeU = vk::SamplerAddressMode::eRepeat;
  samplerInfo.addressModeV = vk::SamplerAddressMode::eRepeat;
  samplerInfo.addressModeW = vk::SamplerAddressMode::eRepeat;
  samplerInfo.mipLodBias = 0.0f;
  samplerInfo.anisotropyEnable = VK_TRUE;
  samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;
  samplerInfo.compareEnable = VK_FALSE;
  samplerInfo.compareOp = vk::CompareOp::eAlways;
  samplerInfo.minLod = 0.0f;
  samplerInfo.maxLod = static_cast<float>(mipLevels);
  samplerInfo.borderColor = vk::BorderColor::eIntOpaqueBlack;
  samplerInfo.unnormalizedCoordinates = VK_FALSE;

  textureSampler = vk::raii::Sampler(device, samplerInfo);
}

std::unique_ptr<vk::raii::CommandBuffer> VulkanRenderer::beginSingleTimeCommands() {
  vk::CommandBufferAllocateInfo allocInfo{};
  allocInfo.commandPool = commandPool;
  allocInfo.level = vk::CommandBufferLevel::ePrimary;
  allocInfo.commandBufferCount = 1;

  std::unique_ptr<vk::raii::CommandBuffer> commandBuffer =
      std::make_unique<vk::raii::CommandBuffer>(
          std::move(vk::raii::CommandBuffers(device, allocInfo).front()));

  vk::CommandBufferBeginInfo beginInfo{};
  beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
  commandBuffer->begin(beginInfo);

  return commandBuffer;
}

void VulkanRenderer::endSingleTimeCommands(vk::raii::CommandBuffer &commandBuffer) {
  commandBuffer.end();

  vk::SubmitInfo submitInfo{};
  submitInfo.commandBufferCount = 1;
  submitInfo.pCommandBuffers = &*commandBuffer;

  graphicsQueue.submit(submitInfo, nullptr);
  graphicsQueue.waitIdle();
}

void VulkanRenderer::createTextureImage() {
  std::ifstream testFile("textures/texture.png");
  if (!testFile.good()) {
    std::cerr << "ERROR: Texture file 'textures/texture.png' not found!" << std::endl;
    throw std::runtime_error("Texture file not found!");
  }
  testFile.close();

  int texWidth, texHeight, texChannels;
  stbi_uc *pixels = stbi_load(TEXTURE_PATH.c_str(), &texWidth, &texHeight,
                              &texChannels, STBI_rgb_alpha);

  if (!pixels) {
    std::cerr << "ERROR: Failed to load texture image: " << stbi_failure_reason() << std::endl;
    throw std::runtime_error("Failed to load texture image!");
  }

  mipLevels = static_cast<uint32_t>(
                  std::floor(std::log2(std::max(texWidth, texHeight)))) + 1;

  vk::DeviceSize imageSize = texWidth * texHeight * 4;

  vk::raii::Buffer stagingBuffer({});
  vk::raii::DeviceMemory stagingBufferMemory({});

  createBuffer(imageSize, vk::BufferUsageFlagBits::eTransferSrc,
               vk::MemoryPropertyFlagBits::eHostVisible |
                   vk::MemoryPropertyFlagBits::eHostCoherent,
               stagingBuffer, stagingBufferMemory);

  void *data = stagingBufferMemory.mapMemory(0, imageSize);
  memcpy(data, pixels, static_cast<size_t>(imageSize));
  stagingBufferMemory.unmapMemory();

  stbi_image_free(pixels);

  createImage(texWidth, texHeight, mipLevels, vk::SampleCountFlagBits::e1,
              vk::Format::eR8G8B8A8Srgb, vk::ImageTiling::eOptimal,
              vk::ImageUsageFlagBits::eTransferSrc |
                  vk::ImageUsageFlagBits::eTransferDst |
                  vk::ImageUsageFlagBits::eSampled,
              vk::MemoryPropertyFlagBits::eDeviceLocal, textureImage,
              textureImageMemory);

  transitionImageLayout(textureImage, vk::ImageLayout::eUndefined,
                        vk::ImageLayout::eTransferDstOptimal, mipLevels);

  copyBufferToImage(stagingBuffer, textureImage,
                    static_cast<uint32_t>(texWidth),
                    static_cast<uint32_t>(texHeight));

  generateMipmaps(textureImage, vk::Format::eR8G8B8A8Srgb, texWidth,
                  texHeight, mipLevels);
}

void VulkanRenderer::createColorResources() {
  vk::Format colorFormat = swapChainImageFormat;

  createImage(swapChainExtent.width, swapChainExtent.height, 1, msaaSamples,
              colorFormat, vk::ImageTiling::eOptimal,
              vk::ImageUsageFlagBits::eTransientAttachment |
                  vk::ImageUsageFlagBits::eColorAttachment,
              vk::MemoryPropertyFlagBits::eDeviceLocal, colorImage,
              colorImageMemory);

  colorImageView = vkutils::createImageView(
      device, colorImage, colorFormat, vk::ImageAspectFlagBits::eColor, 1);
}

void VulkanRenderer::createImage(uint32_t width, uint32_t height, uint32_t mipLevels,
                                 vk::SampleCountFlagBits numSamples, vk::Format format,
                                 vk::ImageTiling tiling, vk::ImageUsageFlags usage,
                                 vk::MemoryPropertyFlags properties, vk::raii::Image &image,
                                 vk::raii::DeviceMemory &imageMemory) {
  vk::ImageCreateInfo imageInfo{};
  imageInfo.imageType = vk::ImageType::e2D;
  imageInfo.format = format;
  imageInfo.extent = vk::Extent3D{width, height, 1};
  imageInfo.mipLevels = mipLevels;
  imageInfo.arrayLayers = 1;
  imageInfo.samples = numSamples;
  imageInfo.tiling = tiling;
  imageInfo.usage = usage;
  imageInfo.sharingMode = vk::SharingMode::eExclusive;

  image = vk::raii::Image(device, imageInfo);

  vk::MemoryRequirements memRequirements = image.getMemoryRequirements();

  vk::MemoryAllocateInfo allocInfo{};
  allocInfo.allocationSize = memRequirements.size;
  allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

  imageMemory = vk::raii::DeviceMemory(device, allocInfo);
  image.bindMemory(imageMemory, 0);
}

void VulkanRenderer::transitionImageLayout(const vk::raii::Image &image,
                                           vk::ImageLayout oldLayout,
                                           vk::ImageLayout newLayout, uint32_t mipLevels) {
  auto commandBuffer = beginSingleTimeCommands();

  vk::ImageMemoryBarrier barrier{};
  barrier.oldLayout = oldLayout;
  barrier.newLayout = newLayout;
  barrier.image = image;
  barrier.subresourceRange = vk::ImageSubresourceRange{
      vk::ImageAspectFlagBits::eColor, 0, mipLevels, 0, 1};

  vk::PipelineStageFlags sourceStage;
  vk::PipelineStageFlags destinationStage;

  if (oldLayout == vk::ImageLayout::eUndefined &&
      newLayout == vk::ImageLayout::eTransferDstOptimal) {
    barrier.srcAccessMask = {};
    barrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;
    sourceStage = vk::PipelineStageFlagBits::eTopOfPipe;
    destinationStage = vk::PipelineStageFlagBits::eTransfer;

  } else if (oldLayout == vk::ImageLayout::eTransferDstOptimal &&
             newLayout == vk::ImageLayout::eShaderReadOnlyOptimal) {
    barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
    barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;
    sourceStage = vk::PipelineStageFlagBits::eTransfer;
    destinationStage = vk::PipelineStageFlagBits::eFragmentShader;

  } else {
    throw std::invalid_argument("Unsupported layout transition!");
  }

  commandBuffer->pipelineBarrier(sourceStage, destinationStage, {}, {}, nullptr, barrier);

  endSingleTimeCommands(*commandBuffer);
}

void VulkanRenderer::generateMipmaps(vk::raii::Image &image, vk::Format imageFormat,
                                     int32_t texWidth, int32_t texHeight, uint32_t mipLevels) {
  vk::FormatProperties formatProperties = physicalGPU.getFormatProperties(imageFormat);

  if (!(formatProperties.optimalTilingFeatures &
        vk::FormatFeatureFlagBits::eSampledImageFilterLinear)) {
    throw std::runtime_error("Texture image format does not support linear blitting!");
  }

  auto commandBuffer = beginSingleTimeCommands();

  vk::ImageMemoryBarrier barrier{};
  barrier.image = *image;
  barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
  barrier.subresourceRange.baseArrayLayer = 0;
  barrier.subresourceRange.layerCount = 1;
  barrier.subresourceRange.levelCount = 1;

  int32_t mipWidth = texWidth;
  int32_t mipHeight = texHeight;

  for (uint32_t i = 1; i < mipLevels; i++) {
    barrier.subresourceRange.baseMipLevel = i - 1;
    barrier.oldLayout = vk::ImageLayout::eTransferDstOptimal;
    barrier.newLayout = vk::ImageLayout::eTransferSrcOptimal;
    barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
    barrier.dstAccessMask = vk::AccessFlagBits::eTransferRead;

    commandBuffer->pipelineBarrier(vk::PipelineStageFlagBits::eTransfer,
                                   vk::PipelineStageFlagBits::eTransfer, {}, {}, {}, barrier);

    vk::ImageBlit blit{};
    blit.srcOffsets[0] = vk::Offset3D{0, 0, 0};
    blit.srcOffsets[1] = vk::Offset3D{mipWidth, mipHeight, 1};
    blit.srcSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
    blit.srcSubresource.mipLevel = i - 1;
    blit.srcSubresource.baseArrayLayer = 0;
    blit.srcSubresource.layerCount = 1;

    blit.dstOffsets[0] = vk::Offset3D{0, 0, 0};
    blit.dstOffsets[1] = vk::Offset3D{mipWidth > 1 ? mipWidth / 2 : 1,
                                      mipHeight > 1 ? mipHeight / 2 : 1, 1};
    blit.dstSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
    blit.dstSubresource.mipLevel = i;
    blit.dstSubresource.baseArrayLayer = 0;
    blit.dstSubresource.layerCount = 1;

    commandBuffer->blitImage(*image, vk::ImageLayout::eTransferSrcOptimal,
                             *image, vk::ImageLayout::eTransferDstOptimal,
                             {blit}, vk::Filter::eLinear);

    barrier.oldLayout = vk::ImageLayout::eTransferSrcOptimal;
    barrier.newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
    barrier.srcAccessMask = vk::AccessFlagBits::eTransferRead;
    barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

    commandBuffer->pipelineBarrier(vk::PipelineStageFlagBits::eTransfer,
                                   vk::PipelineStageFlagBits::eFragmentShader,
                                   {}, {}, {}, barrier);

    if (mipWidth > 1) mipWidth /= 2;
    if (mipHeight > 1) mipHeight /= 2;
  }

  barrier.subresourceRange.baseMipLevel = mipLevels - 1;
  barrier.oldLayout = vk::ImageLayout::eTransferDstOptimal;
  barrier.newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
  barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
  barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

  commandBuffer->pipelineBarrier(vk::PipelineStageFlagBits::eTransfer,
                                 vk::PipelineStageFlagBits::eFragmentShader,
                                 {}, {}, {}, barrier);

  endSingleTimeCommands(*commandBuffer);
}

void VulkanRenderer::copyBufferToImage(const vk::raii::Buffer &buffer, vk::raii::Image &image,
                                       uint32_t width, uint32_t height) {
  std::unique_ptr<vk::raii::CommandBuffer> commandBuffer = beginSingleTimeCommands();

  vk::BufferImageCopy region{};
  region.bufferOffset = 0;
  region.bufferRowLength = 0;
  region.bufferImageHeight = 0;
  region.imageSubresource = vk::ImageSubresourceLayers{vk::ImageAspectFlagBits::eColor, 0, 0, 1};
  region.imageOffset = vk::Offset3D{0, 0, 0};
  region.imageExtent = vk::Extent3D{width, height, 1};

  commandBuffer->copyBufferToImage(buffer, image, vk::ImageLayout::eTransferDstOptimal, {region});

  endSingleTimeCommands(*commandBuffer);
}

void VulkanRenderer::createDescriptorPool() {
  std::array<vk::DescriptorPoolSize, 2> poolSizes = {};
  poolSizes[0] = vk::DescriptorPoolSize(vk::DescriptorType::eUniformBuffer, MAX_FRAMES_IN_FLIGHT);
  poolSizes[1] = vk::DescriptorPoolSize(vk::DescriptorType::eCombinedImageSampler, MAX_FRAMES_IN_FLIGHT);

  vk::DescriptorPoolCreateInfo poolInfo;
  poolInfo.flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet;
  poolInfo.maxSets = MAX_FRAMES_IN_FLIGHT;
  poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
  poolInfo.pPoolSizes = poolSizes.data();

  descriptorPool = device.createDescriptorPool(poolInfo);
}

void VulkanRenderer::createDescriptorSets() {
  std::vector<vk::DescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT, *descriptorSetLayout);

  vk::DescriptorSetAllocateInfo allocInfo;
  allocInfo.descriptorPool = *descriptorPool;
  allocInfo.descriptorSetCount = static_cast<uint32_t>(layouts.size());
  allocInfo.pSetLayouts = layouts.data();

  descriptorSets = device.allocateDescriptorSets(allocInfo);

  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    vk::DescriptorBufferInfo bufferInfo;
    bufferInfo.buffer = *uniformBuffers[i];
    bufferInfo.offset = 0;
    bufferInfo.range = sizeof(UniformBufferObject);

    vk::WriteDescriptorSet descriptorWrite;
    descriptorWrite.dstSet = *descriptorSets[i];
    descriptorWrite.dstBinding = 0;
    descriptorWrite.dstArrayElement = 0;
    descriptorWrite.descriptorCount = 1;
    descriptorWrite.descriptorType = vk::DescriptorType::eUniformBuffer;
    descriptorWrite.pBufferInfo = &bufferInfo;

    vk::DescriptorImageInfo imageInfo;
    imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
    imageInfo.imageView = *textureImageView;
    imageInfo.sampler = *textureSampler;

    vk::WriteDescriptorSet samplerWrite;
    samplerWrite.dstSet = *descriptorSets[i];
    samplerWrite.dstBinding = 1;
    samplerWrite.dstArrayElement = 0;
    samplerWrite.descriptorCount = 1;
    samplerWrite.descriptorType = vk::DescriptorType::eCombinedImageSampler;
    samplerWrite.pImageInfo = &imageInfo;

    std::array<vk::WriteDescriptorSet, 2> descriptorWrites = {descriptorWrite, samplerWrite};
    device.updateDescriptorSets(descriptorWrites, {});
  }
}

void VulkanRenderer::updateUniformBuffer(uint32_t currentImage) {
  static auto startTime = std::chrono::high_resolution_clock::now();

  auto currentTime = std::chrono::high_resolution_clock::now();
  float time = std::chrono::duration<float>(currentTime - startTime).count();

  UniformBufferObject ubo{};
  ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(90.0f),
                          glm::vec3(0.0f, 0.0f, 1.0f));
  ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f),
                         glm::vec3(0.0f, 0.0f, 1.0f));
  ubo.proj = glm::perspective(glm::radians(45.0f),
                              static_cast<float>(swapChainExtent.width) /
                                  static_cast<float>(swapChainExtent.height),
                              0.1f, 10.0f);
  ubo.proj[1][1] *= -1;

  memcpy(uniformBuffersMapped[currentImage], &ubo, sizeof(ubo));
}

void VulkanRenderer::createUniformBuffers() {
  uniformBuffers.clear();
  uniformBuffersMemory.clear();
  uniformBuffersMapped.clear();

  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    vk::DeviceSize bufferSize = sizeof(UniformBufferObject);

    vk::raii::Buffer buffer({});
    vk::raii::DeviceMemory bufferMem({});

    createBuffer(bufferSize, vk::BufferUsageFlagBits::eUniformBuffer,
                 vk::MemoryPropertyFlagBits::eHostVisible |
                     vk::MemoryPropertyFlagBits::eHostCoherent,
                 buffer, bufferMem);

    uniformBuffers.emplace_back(std::move(buffer));
    uniformBuffersMemory.emplace_back(std::move(bufferMem));

    uniformBuffersMapped.emplace_back(uniformBuffersMemory[i].mapMemory(0, bufferSize));
  }
}

void VulkanRenderer::createDescriptorSetLayout() {
  std::array<vk::DescriptorSetLayoutBinding, 2> bindings = {};

  bindings[0] = vk::DescriptorSetLayoutBinding(
      0, vk::DescriptorType::eUniformBuffer, 1, vk::ShaderStageFlagBits::eVertex, nullptr);

  bindings[1] = vk::DescriptorSetLayoutBinding(
      1, vk::DescriptorType::eCombinedImageSampler, 1, vk::ShaderStageFlagBits::eFragment, nullptr);

  vk::DescriptorSetLayoutCreateInfo layoutInfo;
  layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
  layoutInfo.pBindings = bindings.data();

  descriptorSetLayout = vk::raii::DescriptorSetLayout(device, layoutInfo);
}

void VulkanRenderer::copyBuffer(vk::raii::Buffer &srcBuffer, vk::raii::Buffer &dstBuffer,
                                vk::DeviceSize size) {
  vk::CommandBufferAllocateInfo allocInfo{};
  allocInfo.commandPool = *commandPool;
  allocInfo.level = vk::CommandBufferLevel::ePrimary;
  allocInfo.commandBufferCount = 1;

  auto commandBuffers = device.allocateCommandBuffers(allocInfo);
  vk::CommandBuffer commandBuffer = *commandBuffers[0];

  vk::CommandBufferBeginInfo beginInfo{};
  beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
  commandBuffer.begin(beginInfo);

  vk::BufferCopy copyRegion{};
  copyRegion.size = size;
  commandBuffer.copyBuffer(*srcBuffer, *dstBuffer, copyRegion);

  commandBuffer.end();

  vk::SubmitInfo submitInfo{};
  submitInfo.commandBufferCount = 1;
  submitInfo.pCommandBuffers = &commandBuffer;

  graphicsQueue.submit(submitInfo, nullptr);
  graphicsQueue.waitIdle();
}

void VulkanRenderer::createBuffer(vk::DeviceSize size, vk::BufferUsageFlags usage,
                                  vk::MemoryPropertyFlags properties,
                                  vk::raii::Buffer &buffer,
                                  vk::raii::DeviceMemory &bufferMemory) {
  vk::BufferCreateInfo bufferInfo{};
  bufferInfo.size = size;
  bufferInfo.usage = usage;
  bufferInfo.sharingMode = vk::SharingMode::eExclusive;

  buffer = vk::raii::Buffer(device, bufferInfo);

  vk::MemoryRequirements memRequirements = buffer.getMemoryRequirements();

  vk::MemoryAllocateInfo allocInfo{};
  allocInfo.allocationSize = memRequirements.size;
  allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

  bufferMemory = vk::raii::DeviceMemory(device, allocInfo);
  buffer.bindMemory(*bufferMemory, 0);
}

void VulkanRenderer::createIndexBuffer() {
  vk::DeviceSize bufferSize = sizeof(indices[0]) * indices.size();

  vk::raii::Buffer stagingBuffer({});
  vk::raii::DeviceMemory stagingBufferMemory({});
  createBuffer(bufferSize, vk::BufferUsageFlagBits::eTransferSrc,
               vk::MemoryPropertyFlagBits::eHostVisible |
                   vk::MemoryPropertyFlagBits::eHostCoherent,
               stagingBuffer, stagingBufferMemory);

  void *data = stagingBufferMemory.mapMemory(0, bufferSize);
  memcpy(data, indices.data(), (size_t)bufferSize);
  stagingBufferMemory.unmapMemory();

  createBuffer(bufferSize, vk::BufferUsageFlagBits::eTransferDst | vk::BufferUsageFlagBits::eIndexBuffer,
               vk::MemoryPropertyFlagBits::eDeviceLocal, indexBuffer, indexBufferMemory);

  copyBuffer(stagingBuffer, indexBuffer, bufferSize);
}

void VulkanRenderer::createVertexBuffer() {
  vk::DeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

  vk::raii::Buffer stagingBuffer = nullptr;
  vk::raii::DeviceMemory stagingBufferMemory = nullptr;
  createBuffer(bufferSize, vk::BufferUsageFlagBits::eTransferSrc,
               vk::MemoryPropertyFlagBits::eHostVisible |
                   vk::MemoryPropertyFlagBits::eHostCoherent,
               stagingBuffer, stagingBufferMemory);

  void *data = stagingBufferMemory.mapMemory(0, bufferSize);
  memcpy(data, vertices.data(), (size_t)bufferSize);
  stagingBufferMemory.unmapMemory();

  createBuffer(bufferSize, vk::BufferUsageFlagBits::eVertexBuffer | vk::BufferUsageFlagBits::eTransferDst,
               vk::MemoryPropertyFlagBits::eDeviceLocal, vertexBuffer, vertexBufferMemory);

  copyBuffer(stagingBuffer, vertexBuffer, bufferSize);
}

void VulkanRenderer::framebufferResizeCallback(GLFWwindow *window, int, int) {
  auto app = reinterpret_cast<VulkanRenderer *>(glfwGetWindowUserPointer(window));
  app->framebufferResized = true;
}

void VulkanRenderer::createCommandBuffers() {
  commandBuffers.clear();

  vk::CommandBufferAllocateInfo allocInfo;
  allocInfo.commandPool = *commandPool;
  allocInfo.level = vk::CommandBufferLevel::ePrimary;
  allocInfo.commandBufferCount = MAX_FRAMES_IN_FLIGHT;

  commandBuffers = device.allocateCommandBuffers(allocInfo);
}

void VulkanRenderer::createCommandPool() {
  vk::CommandPoolCreateInfo poolInfo;
  poolInfo.flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer;
  poolInfo.queueFamilyIndex = graphicsQueueFamilyIndex;
  commandPool = vk::raii::CommandPool(device, poolInfo);
}

void VulkanRenderer::createSyncObjects() {
  presentCompleteSemaphores.clear();
  renderFinishedSemaphores.clear();
  inFlightFences.clear();

  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    presentCompleteSemaphores.emplace_back(device, vk::SemaphoreCreateInfo());
    renderFinishedSemaphores.emplace_back(device, vk::SemaphoreCreateInfo());
    inFlightFences.emplace_back(device, vk::FenceCreateInfo(vk::FenceCreateFlagBits::eSignaled));
  }
}

void VulkanRenderer::drawFrame() {
  while (vk::Result::eTimeout == device.waitForFences(*inFlightFences[currentFrame], vk::True, UINT64_MAX));

  auto [result, imageIndex] = swapChain.acquireNextImage(UINT64_MAX, *presentCompleteSemaphores[currentFrame], nullptr);

  if (result == vk::Result::eErrorOutOfDateKHR) {
    recreateSwapChain();
    return;
  }

  if (result != vk::Result::eSuccess && result != vk::Result::eSuboptimalKHR) {
    throw std::runtime_error("failed to acquire swap chain image!");
  }

  updateUniformBuffer(currentFrame);

  device.resetFences(*inFlightFences[currentFrame]);
  commandBuffers[currentFrame].reset();

  recordCommandBuffer(imageIndex);

  vk::PipelineStageFlags waitDestinationStageMask(vk::PipelineStageFlagBits::eColorAttachmentOutput);

  vk::SubmitInfo submitInfo;
  submitInfo.waitSemaphoreCount = 1;
  submitInfo.pWaitSemaphores = &*presentCompleteSemaphores[currentFrame];
  submitInfo.pWaitDstStageMask = &waitDestinationStageMask;
  submitInfo.commandBufferCount = 1;
  submitInfo.pCommandBuffers = &*commandBuffers[currentFrame];
  submitInfo.signalSemaphoreCount = 1;
  submitInfo.pSignalSemaphores = &*renderFinishedSemaphores[currentFrame];

  graphicsQueue.submit(submitInfo, *inFlightFences[currentFrame]);

  vk::PresentInfoKHR presentInfoKHR;
  presentInfoKHR.waitSemaphoreCount = 1;
  presentInfoKHR.pWaitSemaphores = &*renderFinishedSemaphores[currentFrame];
  presentInfoKHR.swapchainCount = 1;
  presentInfoKHR.pSwapchains = &*swapChain;
  presentInfoKHR.pImageIndices = &imageIndex;

  result = presentQueue.presentKHR(presentInfoKHR);

  if (result == vk::Result::eErrorOutOfDateKHR || result == vk::Result::eSuboptimalKHR || framebufferResized) {
    framebufferResized = false;
    recreateSwapChain();
  } else if (result != vk::Result::eSuccess) {
    throw std::runtime_error("failed to present swap chain image!");
  }

  currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}

void VulkanRenderer::transition_image_layout(uint32_t imageIndex, vk::ImageLayout oldLayout,
                                             vk::ImageLayout newLayout, vk::AccessFlags2 srcAccessMask,
                                             vk::AccessFlags2 dstAccessMask, vk::PipelineStageFlags2 srcStageMask,
                                             vk::PipelineStageFlags2 dstStageMask) {
  vk::ImageMemoryBarrier2 barrier;
  barrier.oldLayout = oldLayout;
  barrier.newLayout = newLayout;
  barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  barrier.image = swapChainImages[imageIndex];
  barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
  barrier.subresourceRange.baseMipLevel = 0;
  barrier.subresourceRange.levelCount = 1;
  barrier.subresourceRange.baseArrayLayer = 0;
  barrier.subresourceRange.layerCount = 1;
  barrier.srcAccessMask = srcAccessMask;
  barrier.dstAccessMask = dstAccessMask;
  barrier.srcStageMask = srcStageMask;
  barrier.dstStageMask = dstStageMask;

  vk::DependencyInfo dependencyInfo;
  dependencyInfo.imageMemoryBarrierCount = 1;
  dependencyInfo.pImageMemoryBarriers = &barrier;

  commandBuffers[currentFrame].pipelineBarrier2(dependencyInfo);
}

void VulkanRenderer::recordCommandBuffer(uint32_t imageIndex) {
  commandBuffers[currentFrame].begin({});

  // --- COLOR IMAGE BARRIER ---
  vk::ImageMemoryBarrier2 colorBarrier;
  colorBarrier.srcStageMask = vk::PipelineStageFlagBits2::eTopOfPipe;
  colorBarrier.srcAccessMask = {};
  colorBarrier.dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
  colorBarrier.dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
  colorBarrier.oldLayout = vk::ImageLayout::eUndefined;
  colorBarrier.newLayout = vk::ImageLayout::eColorAttachmentOptimal;
  colorBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  colorBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  colorBarrier.image = *colorImage;
  colorBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
  colorBarrier.subresourceRange.baseMipLevel = 0;
  colorBarrier.subresourceRange.levelCount = 1;
  colorBarrier.subresourceRange.baseArrayLayer = 0;
  colorBarrier.subresourceRange.layerCount = 1;

  vk::DependencyInfo colorDependencyInfo;
  colorDependencyInfo.imageMemoryBarrierCount = 1;
  colorDependencyInfo.pImageMemoryBarriers = &colorBarrier;
  commandBuffers[currentFrame].pipelineBarrier2(colorDependencyInfo);

  // --- SWAPCHAIN IMAGE BARRIER ---
  vk::ImageMemoryBarrier2 swapchainBarrier;
  swapchainBarrier.srcStageMask = vk::PipelineStageFlagBits2::eTopOfPipe;
  swapchainBarrier.srcAccessMask = {};
  swapchainBarrier.dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
  swapchainBarrier.dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
  swapchainBarrier.oldLayout = vk::ImageLayout::eUndefined;
  swapchainBarrier.newLayout = vk::ImageLayout::eColorAttachmentOptimal;
  swapchainBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  swapchainBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  swapchainBarrier.image = *swapChainImages[imageIndex];
  swapchainBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
  swapchainBarrier.subresourceRange.baseMipLevel = 0;
  swapchainBarrier.subresourceRange.levelCount = 1;
  swapchainBarrier.subresourceRange.baseArrayLayer = 0;
  swapchainBarrier.subresourceRange.layerCount = 1;

  vk::DependencyInfo swapchainDependencyInfo;
  swapchainDependencyInfo.imageMemoryBarrierCount = 1;
  swapchainDependencyInfo.pImageMemoryBarriers = &swapchainBarrier;
  commandBuffers[currentFrame].pipelineBarrier2(swapchainDependencyInfo);

  // --- DEPTH IMAGE BARRIER ---
  vk::ImageMemoryBarrier2 depthBarrier;
  depthBarrier.srcStageMask = vk::PipelineStageFlagBits2::eTopOfPipe;
  depthBarrier.srcAccessMask = {};
  depthBarrier.dstStageMask = vk::PipelineStageFlagBits2::eEarlyFragmentTests | vk::PipelineStageFlagBits2::eLateFragmentTests;
  depthBarrier.dstAccessMask = vk::AccessFlagBits2::eDepthStencilAttachmentRead | vk::AccessFlagBits2::eDepthStencilAttachmentWrite;
  depthBarrier.oldLayout = vk::ImageLayout::eUndefined;
  depthBarrier.newLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;
  depthBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  depthBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  depthBarrier.image = *depthImage;
  depthBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
  depthBarrier.subresourceRange.baseMipLevel = 0;
  depthBarrier.subresourceRange.levelCount = 1;
  depthBarrier.subresourceRange.baseArrayLayer = 0;
  depthBarrier.subresourceRange.layerCount = 1;

  vk::DependencyInfo depthDependencyInfo;
  depthDependencyInfo.imageMemoryBarrierCount = 1;
  depthDependencyInfo.pImageMemoryBarriers = &depthBarrier;
  commandBuffers[currentFrame].pipelineBarrier2(depthDependencyInfo);

  // --- CLEAR AND ATTACHMENT SETUP ---
  vk::ClearValue clearColor = vk::ClearColorValue(0.0f, 0.0f, 0.0f, 1.0f);
  vk::ClearValue depthClearValue = vk::ClearDepthStencilValue(1.0f, 0);

  vk::RenderingAttachmentInfo colorAttachmentInfo;
  colorAttachmentInfo.imageView = *colorImageView;
  colorAttachmentInfo.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
  colorAttachmentInfo.loadOp = vk::AttachmentLoadOp::eClear;
  colorAttachmentInfo.storeOp = vk::AttachmentStoreOp::eStore;
  colorAttachmentInfo.clearValue = clearColor;

  vk::RenderingAttachmentInfo resolveAttachmentInfo;
  resolveAttachmentInfo.imageView = *swapChainImageViews[imageIndex];
  resolveAttachmentInfo.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
  resolveAttachmentInfo.loadOp = vk::AttachmentLoadOp::eDontCare;
  resolveAttachmentInfo.storeOp = vk::AttachmentStoreOp::eStore;
  resolveAttachmentInfo.clearValue = clearColor;

  colorAttachmentInfo.resolveMode = vk::ResolveModeFlagBits::eAverage;
  colorAttachmentInfo.resolveImageView = resolveAttachmentInfo.imageView;
  colorAttachmentInfo.resolveImageLayout = resolveAttachmentInfo.imageLayout;

  vk::RenderingAttachmentInfo depthAttachmentInfo;
  depthAttachmentInfo.imageView = *depthImageView;
  depthAttachmentInfo.imageLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;
  depthAttachmentInfo.loadOp = vk::AttachmentLoadOp::eClear;
  depthAttachmentInfo.storeOp = vk::AttachmentStoreOp::eDontCare;
  depthAttachmentInfo.clearValue = depthClearValue;

  vk::RenderingInfo renderingInfo;
  renderingInfo.renderArea = vk::Rect2D(vk::Offset2D(0, 0), swapChainExtent);
  renderingInfo.layerCount = 1;
  renderingInfo.colorAttachmentCount = 1;
  renderingInfo.pColorAttachments = &colorAttachmentInfo;
  renderingInfo.pDepthAttachment = &depthAttachmentInfo;
  renderingInfo.pStencilAttachment = nullptr;

  commandBuffers[currentFrame].beginRendering(renderingInfo);

  commandBuffers[currentFrame].bindPipeline(vk::PipelineBindPoint::eGraphics, *graphicsPipeline);

  vk::DeviceSize offsets[] = {0};
  commandBuffers[currentFrame].bindVertexBuffers(0, *vertexBuffer, offsets);
  commandBuffers[currentFrame].bindIndexBuffer(*indexBuffer, 0, vk::IndexType::eUint32);

  commandBuffers[currentFrame].bindDescriptorSets(vk::PipelineBindPoint::eGraphics, *pipelineLayout, 0,
                                                  *descriptorSets[currentFrame], nullptr);

  commandBuffers[currentFrame].setViewport(0, vk::Viewport(0.0f, 0.0f, static_cast<float>(swapChainExtent.width),
                                           static_cast<float>(swapChainExtent.height), 0.0f, 1.0f));
  commandBuffers[currentFrame].setScissor(0, vk::Rect2D(vk::Offset2D(0, 0), swapChainExtent));

  commandBuffers[currentFrame].drawIndexed(static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);

  commandBuffers[currentFrame].endRendering();

  // --- TRANSITION TO PRESENT ---
  vk::ImageMemoryBarrier2 presentBarrier;
  presentBarrier.srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
  presentBarrier.srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
  presentBarrier.dstStageMask = vk::PipelineStageFlagBits2::eBottomOfPipe;
  presentBarrier.dstAccessMask = {};
  presentBarrier.oldLayout = vk::ImageLayout::eColorAttachmentOptimal;
  presentBarrier.newLayout = vk::ImageLayout::ePresentSrcKHR;
  presentBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  presentBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  presentBarrier.image = *swapChainImages[imageIndex];
  presentBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
  presentBarrier.subresourceRange.baseMipLevel = 0;
  presentBarrier.subresourceRange.levelCount = 1;
  presentBarrier.subresourceRange.baseArrayLayer = 0;
  presentBarrier.subresourceRange.layerCount = 1;

  vk::DependencyInfo presentDependencyInfo;
  presentDependencyInfo.imageMemoryBarrierCount = 1;
  presentDependencyInfo.pImageMemoryBarriers = &presentBarrier;

  commandBuffers[currentFrame].pipelineBarrier2(presentDependencyInfo);

  commandBuffers[currentFrame].end();
}

void VulkanRenderer::createGraphicsPipeline() {
  vertexInputInfo = vk::PipelineVertexInputStateCreateInfo{};

  std::vector<char> vertShaderCode = vkutils::readFile("shaders/vert.spv");
  std::vector<char> fragShaderCode = vkutils::readFile("shaders/frag.spv");

  vk::raii::ShaderModule vertShaderModule = createShaderModule(vertShaderCode);
  vk::raii::ShaderModule fragShaderModule = createShaderModule(fragShaderCode);

  vk::PipelineShaderStageCreateInfo vertShaderStageInfo;
  vertShaderStageInfo.stage = vk::ShaderStageFlagBits::eVertex;
  vertShaderStageInfo.module = *vertShaderModule;
  vertShaderStageInfo.pName = "main";

  vk::PipelineShaderStageCreateInfo fragShaderStageInfo;
  fragShaderStageInfo.stage = vk::ShaderStageFlagBits::eFragment;
  fragShaderStageInfo.module = *fragShaderModule;
  fragShaderStageInfo.pName = "main";

  vk::PipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};

  vk::PipelineInputAssemblyStateCreateInfo inputAssembly;
  inputAssembly.topology = vk::PrimitiveTopology::eTriangleList;

  auto bindingDescription = Vertex::getBindingDescription();
  auto attributeDescriptions = Vertex::getAttributeDescriptions();

  vertexInputInfo = vk::PipelineVertexInputStateCreateInfo(
      vk::PipelineVertexInputStateCreateFlags(), 1, &bindingDescription,
      static_cast<uint32_t>(attributeDescriptions.size()), attributeDescriptions.data());

  vk::PipelineViewportStateCreateInfo viewportState;
  viewportState.viewportCount = 1;
  viewportState.scissorCount = 1;

  vk::PipelineRasterizationStateCreateInfo rasterizer;
  rasterizer.depthClampEnable = VK_FALSE;
  rasterizer.rasterizerDiscardEnable = VK_FALSE;
  rasterizer.polygonMode = vk::PolygonMode::eFill;
  rasterizer.cullMode = vk::CullModeFlagBits::eBack;
  rasterizer.frontFace = vk::FrontFace::eCounterClockwise;
  rasterizer.depthBiasEnable = VK_FALSE;
  rasterizer.lineWidth = 1.0f;

  vk::PhysicalDeviceFeatures supportedFeatures = physicalGPU.getFeatures();
  bool sampleRateShadingSupported = supportedFeatures.sampleRateShading;

  vk::PipelineMultisampleStateCreateInfo multisampling;
  multisampling.rasterizationSamples = msaaSamples;
  multisampling.sampleShadingEnable = sampleRateShadingSupported ? VK_TRUE : VK_FALSE;
  multisampling.minSampleShading = sampleRateShadingSupported ? 0.2f : 1.0f;

  vk::PipelineDepthStencilStateCreateInfo depthStencil;
  depthStencil.depthTestEnable = vk::True;
  depthStencil.depthWriteEnable = vk::True;
  depthStencil.depthCompareOp = vk::CompareOp::eLess;
  depthStencil.depthBoundsTestEnable = vk::False;
  depthStencil.stencilTestEnable = vk::False;

  vk::PipelineColorBlendAttachmentState colorBlendAttachment;
  colorBlendAttachment.blendEnable = VK_FALSE;
  colorBlendAttachment.colorWriteMask = vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG |
                                        vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA;

  vk::PipelineColorBlendStateCreateInfo colorBlending;
  colorBlending.logicOpEnable = VK_FALSE;
  colorBlending.attachmentCount = 1;
  colorBlending.pAttachments = &colorBlendAttachment;

  std::vector<vk::DynamicState> dynamicStates = {vk::DynamicState::eViewport, vk::DynamicState::eScissor};

  vk::PipelineDynamicStateCreateInfo dynamicState;
  dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
  dynamicState.pDynamicStates = dynamicStates.data();

  vk::PipelineLayoutCreateInfo pipelineLayoutInfo;
  pipelineLayoutInfo.setLayoutCount = 1;
  pipelineLayoutInfo.pSetLayouts = &*descriptorSetLayout;
  pipelineLayoutInfo.pushConstantRangeCount = 0;
  pipelineLayout = vk::raii::PipelineLayout(device, pipelineLayoutInfo);

  vk::PipelineRenderingCreateInfo pipelineRenderingCreateInfo;
  pipelineRenderingCreateInfo.colorAttachmentCount = 1;
  pipelineRenderingCreateInfo.pColorAttachmentFormats = &swapChainSurfaceFormat.format;
  pipelineRenderingCreateInfo.depthAttachmentFormat = findDepthFormat();

  vk::GraphicsPipelineCreateInfo pipelineInfo;
  pipelineInfo.pNext = &pipelineRenderingCreateInfo;
  pipelineInfo.stageCount = 2;
  pipelineInfo.pStages = shaderStages;
  pipelineInfo.pVertexInputState = &vertexInputInfo;
  pipelineInfo.pInputAssemblyState = &inputAssembly;
  pipelineInfo.pViewportState = &viewportState;
  pipelineInfo.pRasterizationState = &rasterizer;
  pipelineInfo.pMultisampleState = &multisampling;
  pipelineInfo.pDepthStencilState = &depthStencil;
  pipelineInfo.pColorBlendState = &colorBlending;
  pipelineInfo.pDynamicState = &dynamicState;
  pipelineInfo.layout = *pipelineLayout;
  pipelineInfo.renderPass = nullptr;

  graphicsPipeline = vk::raii::Pipeline(device, nullptr, pipelineInfo);
}

vk::raii::ShaderModule VulkanRenderer::createShaderModule(const std::vector<char> &code) {
  vk::ShaderModuleCreateInfo createInfo;
  createInfo.codeSize = code.size();
  createInfo.pCode = reinterpret_cast<const uint32_t *>(code.data());
  return vk::raii::ShaderModule(device, createInfo);
}

void VulkanRenderer::createSurface() {
  VkSurfaceKHR _surface;
  if (glfwCreateWindowSurface(*instance, window, nullptr, &_surface) != 0) {
    throw std::runtime_error("Failed to create window surface!");
  }
  surface = vk::raii::SurfaceKHR(instance, _surface);
}

void VulkanRenderer::setupDebugMessenger() {
  if (!enableValidationLayers) {
    return;
  }

  vk::DebugUtilsMessageSeverityFlagsEXT severityFlags(
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eError);

  vk::DebugUtilsMessageTypeFlagsEXT messageTypeFlags(
      vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |
      vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |
      vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation);

  vk::DebugUtilsMessengerCreateInfoEXT debugUtilsMessengerCreateInfoEXT;
  debugUtilsMessengerCreateInfoEXT.messageSeverity = severityFlags;
  debugUtilsMessengerCreateInfoEXT.messageType = messageTypeFlags;
  debugUtilsMessengerCreateInfoEXT.pfnUserCallback = debugCallback;

  debugMessenger = instance.createDebugUtilsMessengerEXT(debugUtilsMessengerCreateInfoEXT);
}

VKAPI_ATTR vk::Bool32 VKAPI_CALL VulkanRenderer::debugCallback(
    vk::DebugUtilsMessageSeverityFlagBitsEXT severity,
    vk::DebugUtilsMessageTypeFlagsEXT type,
    const vk::DebugUtilsMessengerCallbackDataEXT *pCallbackData, void *) {
  if (severity == vk::DebugUtilsMessageSeverityFlagBitsEXT::eError ||
      severity == vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning) {
    std::cerr << "validation layer: type " << vk::to_string(type)
              << " msg: " << pCallbackData->pMessage << std::endl;
  }
  return vk::False;
}

std::vector<const char *> VulkanRenderer::getRequiredExtensions() {
  uint32_t glfwExtensionCount = 0;
  auto glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

  std::vector<const char *> extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);

  if (enableValidationLayers) {
    extensions.push_back(vk::EXTDebugUtilsExtensionName);
  }

  extensions.push_back(vk::KHRGetPhysicalDeviceProperties2ExtensionName);
  return extensions;
}

void VulkanRenderer::createInstance() {
  vk::ApplicationInfo appInfo("CS-5990 Renderer", VK_MAKE_VERSION(1, 0, 0),
                              "No Engine", VK_MAKE_VERSION(1, 0, 0),
                              VK_API_VERSION_1_3);

  std::vector<const char *> requiredLayers;
  if (enableValidationLayers) {
    requiredLayers.assign(validationLayers.begin(), validationLayers.end());
  }

  auto layerProperties = context.enumerateInstanceLayerProperties();
  for (auto const &requiredLayer : requiredLayers) {
    if (std::none_of(layerProperties.begin(), layerProperties.end(),
                     [requiredLayer](auto const &layerProperty) {
                       return strcmp(layerProperty.layerName, requiredLayer) == 0;
                     })) {
      throw std::runtime_error("Required layer not supported: " + std::string(requiredLayer));
    }
  }

  auto requiredExtensions = getRequiredExtensions();

#if defined(__APPLE__)
  requiredExtensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
#endif

  auto extensionProperties = context.enumerateInstanceExtensionProperties();
  for (auto const &requiredExtension : requiredExtensions) {
    if (std::none_of(extensionProperties.begin(), extensionProperties.end(),
                     [requiredExtension](auto const &extensionProperty) {
                       return strcmp(extensionProperty.extensionName, requiredExtension) == 0;
                     })) {
      throw std::runtime_error("Required extension not supported: " + std::string(requiredExtension));
    }
  }

  vk::InstanceCreateInfo createInfo;
  createInfo.pApplicationInfo = &appInfo;
  createInfo.enabledLayerCount = static_cast<uint32_t>(requiredLayers.size());
  createInfo.ppEnabledLayerNames = requiredLayers.data();
  createInfo.enabledExtensionCount = static_cast<uint32_t>(requiredExtensions.size());
  createInfo.ppEnabledExtensionNames = requiredExtensions.data();

#if defined(__APPLE__)
  createInfo.flags = vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR;
#endif

  instance = vk::raii::Instance(context, createInfo);
}

void VulkanRenderer::createImageViews() {
  swapChainImageViews.clear();
  swapChainImageViews.reserve(swapChainImages.size());

  for (auto &image : swapChainImages) {
    swapChainImageViews.emplace_back(
        vkutils::createImageView(device, image, swapChainImageFormat,
                                 vk::ImageAspectFlagBits::eColor, 1));
  }
}

void VulkanRenderer::createSwapChain() {
  auto surfaceCapabilities = physicalGPU.getSurfaceCapabilitiesKHR(*surface);

  auto chosenSurfaceFormat = chooseSwapSurfaceFormat(physicalGPU.getSurfaceFormatsKHR(*surface));
  swapChainImageFormat = chosenSurfaceFormat.format;
  swapChainSurfaceFormat = chosenSurfaceFormat;
  auto swapChainColorSpace = chosenSurfaceFormat.colorSpace;

  swapChainExtent = chooseSwapExtent(surfaceCapabilities);

  auto minImageCount = std::max(3u, surfaceCapabilities.minImageCount);
  minImageCount = (surfaceCapabilities.maxImageCount > 0 && minImageCount > surfaceCapabilities.maxImageCount)
                      ? surfaceCapabilities.maxImageCount
                      : minImageCount;

  auto presentMode = chooseSwapPresentMode(physicalGPU.getSurfacePresentModesKHR(*surface));

  vk::SwapchainCreateInfoKHR swapChainCreateInfo;
  swapChainCreateInfo.surface = *surface;
  swapChainCreateInfo.minImageCount = minImageCount;
  swapChainCreateInfo.imageFormat = swapChainImageFormat;
  swapChainCreateInfo.imageColorSpace = swapChainColorSpace;
  swapChainCreateInfo.imageExtent = swapChainExtent;
  swapChainCreateInfo.imageArrayLayers = 1;
  swapChainCreateInfo.imageUsage = vk::ImageUsageFlagBits::eColorAttachment;
  swapChainCreateInfo.imageSharingMode = vk::SharingMode::eExclusive;
  swapChainCreateInfo.preTransform = surfaceCapabilities.currentTransform;
  swapChainCreateInfo.compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eOpaque;
  swapChainCreateInfo.presentMode = presentMode;
  swapChainCreateInfo.clipped = true;

  swapChain = vk::raii::SwapchainKHR(device, swapChainCreateInfo);

  swapChainImages.clear();
  auto images = swapChain.getImages();
  swapChainImages.reserve(images.size());

  for (auto &image : images) {
    swapChainImages.emplace_back(device, image);
  }
}

vk::Extent2D VulkanRenderer::chooseSwapExtent(const vk::SurfaceCapabilitiesKHR &capabilities) {
  if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
    return capabilities.currentExtent;
  }

  int width, height;
  glfwGetFramebufferSize(window, &width, &height);

  return {std::clamp<uint32_t>(width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width),
          std::clamp<uint32_t>(height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height)};
}

vk::PresentModeKHR VulkanRenderer::chooseSwapPresentMode(
    const std::vector<vk::PresentModeKHR> &availablePresentModes) {
  for (const auto &availablePresentMode : availablePresentModes) {
    if (availablePresentMode == vk::PresentModeKHR::eMailbox) {
      return availablePresentMode;
    }
  }
  return vk::PresentModeKHR::eFifo;
}

vk::SurfaceFormatKHR VulkanRenderer::chooseSwapSurfaceFormat(
    const std::vector<vk::SurfaceFormatKHR> &availableFormats) {
  for (const auto &availableFormat : availableFormats) {
    if (availableFormat.format == vk::Format::eB8G8R8A8Srgb &&
        availableFormat.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {
      return availableFormat;
    }
  }
  return availableFormats[0];
}

void VulkanRenderer::pickLogicalGPU() {
  std::vector<vk::QueueFamilyProperties> queueFamilyProperties = physicalGPU.getQueueFamilyProperties();

  uint32_t graphicsIndex = static_cast<uint32_t>(queueFamilyProperties.size());
  uint32_t presentIndex = static_cast<uint32_t>(queueFamilyProperties.size());

  for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) {
    if (queueFamilyProperties[i].queueFlags & vk::QueueFlagBits::eGraphics) {
      if (graphicsIndex == queueFamilyProperties.size()) {
        graphicsIndex = i;
      }
      if (physicalGPU.getSurfaceSupportKHR(i, *surface)) {
        graphicsIndex = i;
        presentIndex = i;
        break;
      }
    }
  }

  if (presentIndex == queueFamilyProperties.size()) {
    for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) {
      if (physicalGPU.getSurfaceSupportKHR(i, *surface)) {
        presentIndex = i;
        break;
      }
    }
  }

  if (graphicsIndex == queueFamilyProperties.size()) {
    for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) {
      if (queueFamilyProperties[i].queueFlags & vk::QueueFlagBits::eGraphics) {
        graphicsIndex = i;
        break;
      }
    }
  }

  if ((graphicsIndex == queueFamilyProperties.size()) || (presentIndex == queueFamilyProperties.size())) {
    throw std::runtime_error("No graphics or present queue family found!");
  }

  graphicsQueueFamilyIndex = graphicsIndex;
  std::set<uint32_t> uniqueQueueFamilies = {graphicsIndex, presentIndex};
  std::vector<vk::DeviceQueueCreateInfo> queueCreateInfos;
  float queuePriority = 1.0f;

  for (uint32_t queueFamily : uniqueQueueFamilies) {
    vk::DeviceQueueCreateInfo queueCreateInfo;
    queueCreateInfo.queueFamilyIndex = queueFamily;
    queueCreateInfo.queueCount = 1;
    queueCreateInfo.pQueuePriorities = &queuePriority;
    queueCreateInfos.push_back(queueCreateInfo);
  }

  vk::PhysicalDeviceFeatures supportedFeatures = physicalGPU.getFeatures();
  bool sampleRateShadingSupported = supportedFeatures.sampleRateShading;

  vk::StructureChain<vk::PhysicalDeviceFeatures2, vk::PhysicalDeviceVulkan13Features,
                     vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT> featureChain;

  if (sampleRateShadingSupported) {
    featureChain.get<vk::PhysicalDeviceFeatures2>().features.sampleRateShading = VK_TRUE;
  }

  featureChain.get<vk::PhysicalDeviceVulkan13Features>().dynamicRendering = true;
  featureChain.get<vk::PhysicalDeviceVulkan13Features>().synchronization2 = true;
  featureChain.get<vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT>().extendedDynamicState = true;

  vk::DeviceCreateInfo deviceCreateInfo;
  deviceCreateInfo.pNext = &featureChain.get<vk::PhysicalDeviceFeatures2>();
  deviceCreateInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
  deviceCreateInfo.pQueueCreateInfos = queueCreateInfos.data();
  deviceCreateInfo.enabledExtensionCount = static_cast<uint32_t>(gpuExtensions.size());
  deviceCreateInfo.ppEnabledExtensionNames = gpuExtensions.data();

  device = vk::raii::Device(physicalGPU, deviceCreateInfo);

  graphicsQueue = vk::raii::Queue(device, graphicsIndex, 0);
  presentQueue = vk::raii::Queue(device, presentIndex, 0);
}

void VulkanRenderer::pickPhysicalGPU() {
  std::vector<vk::raii::PhysicalDevice> gpus = instance.enumeratePhysicalDevices();

  for (auto const &gpu : gpus) {
    auto queueFamilies = gpu.getQueueFamilyProperties();

    bool isSuitable = gpu.getProperties().apiVersion >= VK_API_VERSION_1_3;

    const auto qfpIter = std::find_if(queueFamilies.begin(), queueFamilies.end(),
                                      [](vk::QueueFamilyProperties const &qfp) {
                                        return (qfp.queueFlags & vk::QueueFlagBits::eGraphics) !=
                                               static_cast<vk::QueueFlags>(0);
                                      });
    isSuitable = isSuitable && (qfpIter != queueFamilies.end());

    auto extensions = gpu.enumerateDeviceExtensionProperties();
    bool found = true;
    for (auto const &extension : gpuExtensions) {
      auto extensionIter = std::find_if(extensions.begin(), extensions.end(), [extension](auto const &ext) {
        return strcmp(ext.extensionName, extension) == 0;
      });
      found = found && extensionIter != extensions.end();
    }
    isSuitable = isSuitable && found;

    if (isSuitable) {
      physicalGPU = gpu;
      msaaSamples = getMaxUsableSampleCount();
      return;
    }
  }

  throw std::runtime_error("Failed to find a GPU that supports Vulkan 1.3!");
}

void VulkanRenderer::recreateSwapChain() {
  int width = 0, height = 0;
  glfwGetFramebufferSize(window, &width, &height);

  while (width < 1 || height < 1) {
    glfwGetFramebufferSize(window, &width, &height);
    glfwWaitEvents();
  }

  device.waitIdle();
  cleanupSwapChain();

  createSwapChain();
  createImageViews();
  createColorResources();
  createDepthResources();
  createCommandBuffers();
  createSyncObjects();
}

void VulkanRenderer::cleanupSwapChain() {
  colorImageView = nullptr;
  colorImage = nullptr;
  colorImageMemory = nullptr;

  swapChainImageViews.clear();
  swapChain = nullptr;
}

void VulkanRenderer::initWindow() {
  glfwInit();
  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
  window = glfwCreateWindow(WIDTH, HEIGHT, "Accelerender", nullptr, nullptr);
  glfwSetWindowUserPointer(window, this);
  glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);
}

void VulkanRenderer::initVulkan() {
  createInstance();
  setupDebugMessenger();
  createSurface();
  pickPhysicalGPU();
  pickLogicalGPU();
  createSwapChain();
  createImageViews();
  createColorResources();
  createDescriptorSetLayout();
  createGraphicsPipeline();
  createCommandPool();
  createDepthResources();
  createTextureImage();
  createTextureImageView();
  createTextureSampler();
  loadModel();
  createVertexBuffer();
  createIndexBuffer();
  createUniformBuffers();
  createDescriptorPool();
  createDescriptorSets();
  createCommandBuffers();
  createSyncObjects();
}

void VulkanRenderer::mainLoop() {
  int frameCounter = 0;
  const int profileEveryNFrames = 10;

  while (!glfwWindowShouldClose(window)) {
    glfwPollEvents();

    bool doProfile = (frameCounter % profileEveryNFrames == 0);

    if (doProfile) {
      ChronoProfiler::ScopedFrame frame;
      PROFILE_SCOPE("drawFrame()");
      drawFrame();
    } else {
      drawFrame();
    }

    if (doProfile) {
      profilerUI.update();
      profilerUI.render();
    }

    frameCounter++;
  }

  device.waitIdle();
  ChronoProfiler::exportToJSON("profile_output.json");
}

void VulkanRenderer::cleanup() {
  cleanupSwapChain();
  glfwDestroyWindow(window);
  glfwTerminate();
}
